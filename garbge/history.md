#### 阿甘

1. 对微服务怎么看？
2. 项目中的亮点？（针对项目提问）
3. 如何针对峰值流量进行优化？

#### 简历剖析

1. 熟悉常用web框架，使用过gin,kratos。

    1. 一个基本的框架？
        1. 框架的设定具有针对性，倾向性。
        2. 框架架构定义，也就是框架的分层，模块的划分，模块之间的交互。
        3. 可以分为三个方面，基础设施，服务治理，打包部署（docker&CI/CD）。
            [image](../images/2020-3-3/30.jpg)

    2. 掌握gin框架，gin 中的特性，handlerchain? context? redix tree?
        1. redix tree? gin 中基于压缩前缀树的方式作为路由树的数据结构，对应于 9 种 http 方法共有 9 棵树。
            - 前缀树：前缀树又称trie树，是一种基于字符串公共前缀构建索引的树状结构，核心点包括：
                1. 除根节点之外，每个节点对应一个字符。
                2. 从根节点到某一个节点，路径上经过的字符串串联起来，即为该节点对应的字符串。
                3. 尽可能复用公共前缀，如无必要不分配新的节点。
            - 压缩前缀树：又称基数树或redix tree,是对前缀树的改良版本，优化点主要在于空间的节省，核心策略体现在：
                1. 倘若某个子节点是父节点的唯一子节点，且不存在以父节点结尾的情况，则将父节点与子节点合并。
            - 补偿策略：
                1. 节点路径下，挂载子节点越多，认为该节点下路径被索引的概率越大，优先级越高，优先放在左边。
            - 为什么不使用map数据结构？
               1. map 适合于精确，一对一查询，不适合模糊匹配，* 匹配。redix tree 更适合前缀匹配。
               2. map 与数据量有关，数据量越大，map 查询越慢; redix tree 与路径长度有关，与量级没有关系。
               3. 路径基于分组的公共前缀，可以针对前缀进行中间件特殊处理；路由组与树级结构更加契合。
            - code?
                - path: 节点的相对路径，拼接上RouterGroup中的basePath 作为前缀后才能拿到完整的路由 path
                - indices: 由各个子节点path 首字母组成的字符串，用于判断当前节点下是否存在子节点，以及子节点的位置。
                - priority: 途径本节点的路由数量，反映出本节点在父节点中被检索的优先级。
                - children: 子节点集合，用于存储子节点。
                - handlers: 处理器链，用于处理匹配到该路由的请求。
                - fullPath: 路由的完整路径，由RouterGroup中的basePath与path拼接而成。
                - wildChild: 是否存在有通配子节点。
                - nType: 节点类型，用于区分普通节点，参数节点，通配节点等。

                [code](../images/2020-3-3/31.jpg)

        2. context?
            gin.Context 的定位是对应于一次 http 请求，贯穿于整条 handlersChain 调用链路的上下文，其中包含了如下核心字段：

            1. gin.Context 作为处理 http请求的通用数据结构，不可避免的频繁创建和销毁，为了缓解GC压力，gin.Context 采用对象池 sync.Pool 复用机制。
                - http 请求到达时，从pool 中获取Context,倘若池子为空，通过pool.New方法构造新的Context补上空缺。
                - http 请求处理完毕，将Context归还给pool，等待下一次复用。

                - sync.Pool 并不是真正意义上的缓存，成为回收站更合适，放入其中的数据在逻辑意义上都是已经被删除的，但在物理意义上仍然存在，这些数据可以存活两轮GC，在此期间倘若有获取的需求，仍然可以复用。

            [code](../images/2020-3-3/32.jpg)
            1. Request/Writer: http请求和响应的 reader,write 入口
            2. handlers: 本次http请求对应的处理函数链。
            3. index: 当前的处理进度，即处理链路处于函数链的索引位置。
            4. engine: engine, 当前请求对应的路由引擎。
            5. mu: 用于保护map的读写互斥锁。
            6. keys: 缓存在 handlers 链上共享数据的map。

2. 负责过项目重构，设计数据库迁移，权限设计，数据存储等？

    1. 数据迁移？
        > 负责全量及增量迁移，负责MySQL到PG切换；

        1. 全量迁移：
            1. 理清业务逻辑，迁移的数据所对应的迁移后数据表
            2. 数据表表字段换（包含字段类型，长度，枚举等），唯一对应值关系映射表搭建
            3. 数据表数据校验，数据量校验及抽取+首位值校验
            4. 数据表 ID 范围记录，留有一定长度做区分或特殊处理
            5. 迁移日期记录 特殊数据处理

        2. 增量迁移：
            1. 数据调整以迁移后数据为准，迁移前数据调整不做处理
            2. 从上次记录位置开始调整

        3. MySQL 到PG切换：
            - 代码调整
            - 数据调整
                1. 区分大小写处理
                2. Group By 分组处理
                3. 字段零值处理
                4. 字段类型处理
                5. 函数不一致处理

        不足：
        ​ 该迁移为宕机迁移，对用户体验不是很好，是否可以无感迁移，动态迁移？

    2. 权限设计？

    3. 数据存储？
        云服务与私有化服务共存，工厂模式，选择存储类型存储。

3. 熟悉常用数据库，消息队列，中间件？
    1. mysql 数据库相关知识？
    2. redis 数据库相关知识？
    3. 消息队列相关知识？内存队列，延迟队列如何设计？
    4. 中间件相关知识？还有哪些中间件？

4. 熟悉容器化开发，私有部署？
    1. 容器化开发的流程？
       1. 构建环境镜像，集成基本开发环境。
       2. 利用dev containers 在容器内进行开发，打包。
    2. 容器化开发中遇到的问题？
       1. 数据丢失，文件挂载，不方便。
    3. 私有部署的流程？
       1. 镜像拉取，服务文件挂载，服务脚本编辑，程序打包。
       2. 拷贝压缩包，使用ansible执行脚本，启动服务。

5. 对devops，微服务，服务治理有一定经验？
    1. devops？
    2. 微服务？
    3. 服务治理？
        1. 链路追踪 opentracing
            1. 少量服务并不需要trace，增加系统复杂度，增加系统开销,大量服务需要trace
            2. 基本元素
                1. TraceId: 全局唯一，一次请求唯一
                2. SpanId: 全局唯一，一次请求内唯一
                3. ParentId: 父节点SpanId
            3. 大体流程
                1. 创建 Trace：当一个请求到达系统的入口点时，系统会创建一个新的 Trace。Trace 通常由一个唯一的 TraceID 标识。
                2. 创建 Span：在 Trace 的每个步骤中，系统会创建一个新的 Span。Span 通常由一个唯一的 SpanID 标识，并且有一个 ParentID，表示这个 Span 的父 Span。
                3. 记录信息：在 Span 的每个步骤中，系统会记录一些信息，例如，开始时间、结束时间、持续时间、错误信息等。这些信息可以帮助你了解请求在系统中的执行情况。
                4. 发送数据：当请求完成时，系统会将 Trace 的数据发送到追踪系统。追踪系统会将这些数据存储起来，并提供一个 Web 界面来查看追踪数据。
                5. 查看数据：你可以使用追踪系统的 Web 界面来查看 Trace 的数据。你可以查看 Trace 的路径，每个步骤的开始时间、结束时间和持续时间，以及错误信息等。
            4. 使用jaeger 的几种参数配置
                1. 哪些请求会被追踪，所有，一定的概率，一定的速率多种方式
                2. 追踪数据发送到collector的频率，默认值为1秒
                3. 追踪数据在发送到collector 之前的队列大小，默认1000。如果收集满了，新的追踪数据会被丢弃，直到有空间。
                4. 追踪数据包的最大大小，默认值为4096字节，4k。如果追踪数据包的大小超过了这个值，那么追踪数据包会被分割成多个小包发送。
            5. 具体使用
                1. http/grpc 集成中间件, 数据库中间件
                2. 采集点：跨进程调用，代码中埋点（span.start,end）

        2. 服务熔断、降级
            1. 熔断的含义：当服务出现异常，超过一定时间，一定次数，一定比例，则熔断，不再调用服务，直接返回错误（可以降级）。后续暂停一段时间会不断尝试请求，探测服务是否恢复，直到服务恢复正常。
            2. 降级：分两个维度来理解，一种小的，当熔断后，服务要么返回错误，要么返回默认值，要么调用次级服务（这种就是降级）。一种大的，当业务场景允许，某些服务需要更多资源，流量时，对部分服务关掉。
            3. hystrix 熔断的三种状态
                - `关闭(Closed)`：在这种状态下，我们需要一个计数器来记录调用失败的次数和总的请求次数，如果在某个时间窗口内，失败的失败率达到预设的阈值，则切换到断开状态，此时开启一个超时时间，当到达该时间则切换到半关闭状态，该超时时间是给了系统一次机会来修正导致调用失败的错误，以回到正常的工作状态。在关闭状态下，调用错误是基于时间的，在特定的时间间隔内会重置，这能够防止偶然错误导致熔断器进入断开状态
                - `打开(Open)`：在该状态下，发起请求时会立即返回错误，一般会启动一个超时计时器，当计时器超时后，状态切换到半打开状态，也可以设置一个定时器，定期的探测服务是否恢复
                - `半打开(Half-Open)`：在该状态下，允许应用程序一定数量的请求发往被调用服务，如果这些调用正常，那么可以认为被调用服务已经恢复正常，此时熔断器切换到关闭状态，同时需要重置计数。如果这部分仍有调用失败的情况，则认为被调用方仍然没有恢复，熔断器会切换到打开状态，然后重置计数器，半打开状态能够有效防止正在恢复中的服务被突然大量请求再次打垮

        4. 服务限流
            1. 最常见的三种情况：突发流量（双十一场景），恶意流量（恶意攻击），业务本身需要等。
            2. 基于计数的限流器：计数器限流器是最简单的一种限流器，它通过维护一个计数器来记录在一定时间窗口内的请求次数，当请求次数超过设定的阈值时，就拒绝新的请求。这种限流器实现简单，但是无法应对突发流量，因为计数器在时间窗口结束时会被重置，所以无法处理短时间内的大量请求。
            3. 基于滑动窗口的限流：滑动窗口限流器通过维护一个时间窗口内的请求次数来限制流量，它将时间窗口划分为多个小的时间段，每个时间段内都有一个计数器来记录请求次数。当请求到达时，它会检查当前时间窗口内的所有时间段，如果任何一个时间段的请求次数超过了设定的阈值，就拒绝新的请求。这种限流器可以应对突发流量，因为它可以处理短时间内的大量请求。
            4. 漏桶算法：类似于队列，请求先入队列，然后按照固定速率流出，如果队列满了，则拒绝请求。无法处理突发情况。
            5. 令牌桶算法：稳定放入桶中，请求到达，从桶中取出令牌，如果桶中没有令牌，则拒绝请求。可以应对突发情况。
            6. 插件引入 "github.com/juju/ratelimit"

        5. 日志监控 prometheus,grafana
        6. 配置中心 etcd, consul
        7. 服务注册与发现 nacos
        8. 服务网关 grpcgateway

6. 项目中遇到的问题，如何解决？
    1. 梳理问题，什么原因导致的，是否频繁，是否固定时间段出现，是否可以复现。
    2. 分析问题，根据问题现象，分析问题原因，是否是代码问题，是否是环境问题，是否是配置问题，是否是第三方问题。
    3. 解决问题，通过经验，查询资料，请教同事去解决。

7. 对未来的规划？
    一定要清晰，具体，有目标。
    短期：探索云原生这一块，docker, k8s内部实现去详细学习一下。
    中期：web3.0,区块链详细学习一下。

8. 蜂鸟项目
    1. 提升千万级数据检索速度，优化？
        1. 本身使用tidb分布式数据库，内部实现分布式存储。
        2. 对数据进行分区，按照分区进行数据检索
        3. 使用延迟，批量写入，缓存读取等优化。
        --------
        1. 多主多从，实现分片集群，
        2. 服务降级，其他无关紧要任务降级
        3. 服务限流，限制查询数量。

        4. 多节点部署，负载均衡。
        5. 服务拆分，数据拆分，多个服务组装数据返回。
        6. 数据库重新设计，代码优化，索引优化，查询优化, 并发写入。

    2. 压缩网闸传输数据，与多服务对接分批返回响应？
        1. 对传输数据进行压缩，减少传输数据量，提高传输速度。
        2. 对多服务进行分批返回响应，减少服务压力，提高服务响应速度。

    3. 实现布控服务业务拆分，多副本部署？
        1. 布控服务业务拆分，业务服务，任务服务。
            - 业务服务负责接收客户端请求，对请求进行响应，任务创建直接通过grpc协议调度，删改进行广播提供grpc流供订阅。
            - 任务服务负责提供grpc创建协议，入队，任务执行。订阅业务服务广播，进行任务调度的实时同步。

    4. 实现摘要复用，动态缩略图等优化？
        1. 对已经进行分析的视频流时间段进行复用，减少重复分析。
        2. 页面上对摘要图响应较长，原因是摘要图比较大，如果对所有的摘要图进行缩略图处理，完全没有必要，因为生成的摘要图不一定都会查看。因此对已经查看的缩略图进行异步处理，下次返回的时候直接返回缩略图。

    5. 集成链路追踪，限流，熔断等？
        1. 链路追踪，使用jaeger集成，实现服务调用链路追踪，方便服务问题排查。
        2. 限流，使用ratelimit实现限流。
            限流几种方式，计数器，令牌桶，漏桶，滑动窗口。
        3. 熔断，使用hystrix实现熔断。
            熔断的状态：开启熔断，关闭熔断，半开状态。
        4. 日志监控，使用prometheus实现日志监控。

9. 云平台项目
    1. 替换rust技术栈，优化？
        1. 对业务分析，梳理服务逻辑，参考原有协议，传参，返回值等
        2. 画图

    2. 重构arstudio，优化？
        1. 对业务进行分析，对冗余服务进行合并，优化
    3. mysql->pg数据迁移？
        1. 代码（查询语句部分不能使用，类型字段调整）
        2. 数据迁移（全量及增量迁移，保证新老系统稳定过渡）

    4. rbac权限系统设计？
        1. 用户属于角色，同时用户属于角色，如属于部门，输入管理员等。
        2. 角色具备操作某资源权限，例如 管理员具备查看用户列表，查看角色列表等权限。

    5. excel 通用，导出插件，自定义格式？
        1. 基于reflect 反射实现字段忽略，重命名，值方法调整等

10. oa 项目
    1. 数据迁移，mysql&ftp服务器 迁移？
        1. 基于binlog日志迁移？
        2. 基于ftp文档迁移
    2. 内部考核系统？
        1. 考题导入，excel导入？
        2. 考题随机抽取，随机生成答案？
        3. 考题答案多选比对
        4. PDF处理
        5. 考试时间限制，考试时间到自动交卷
        6. 考试结果统计，生成图表

    3. 网盘服务，在线预览？
        1. 实现文件夹及文件父子级权限
        2. 基于自然算法实现父级排序
        3. 实现文档在线预览
        4. 实现文件增删改查权限控制

    4. casbin 权限，用户，角色，权限管理？
        casbin 是一个强大且高效的开源访问控制库，支持各种访问模型，用于在全局范围内执行授权。

        1. 权限（Permission）
            权限是指用户对特定资源（如数据、功能、服务）的访问或操作能力。权限通常由三元组表示，即 (Subject, Object, Action)，其中：

            Subject：主体，即请求权限的用户或实体。
            Object：对象，即权限所针对的资源。
            Action：动作，即对资源的操作，如读取、写入、删除等。
        2. 策略（Policy）
            策略是定义权限的规则或规则集。策略可以基于不同的因素，如时间、地点、设备等，来决定是否授予某个权限。策略通常由三元组 (Subject, Object, Action) 表示。

        3. 影响（Effect）
            影响是指策略的结果，即是否授予或拒绝某个权限。影响通常有两种：允许（Allow）和拒绝（Deny）。

        4. 请求（Request）
            请求是指用户对特定资源进行访问或操作的请求。请求通常由三元组 (Subject, Object, Action) 表示。

        5. 匹配器（Matcher）
            匹配器是用于匹配请求和策略的工具。匹配器根据请求和策略中的条件，判断请求是否满足策略的要求。

        6. 角色（Role）
            角色是权限的集合，用于简化权限管理。用户可以拥有一个或多个角色，每个角色拥有特定的权限。角色通常由 (Subject, Role) 表示。

        7. 权限管理（Permission Management）
            权限管理是指对用户、角色和权限进行管理的过程，包括权限的授予、撤销、更新等操作。

        8. 角色管理（Role Management）
            角色管理是指对角色进行管理的过程，包括角色的创建、删除、更新等操作。

        9. 权限模型（Permission Model）
            权限模型是权限管理的一种方法或框架，用于定义和管理权限。常见的权限模型有：

            访问控制列表（ACL，Access Control List）：将权限直接授予用户或角色。
            基于角色的访问控制（RBAC，Role-Based Access Control）：将权限授予角色，用户通过角色获得权限。
            基于属性的访问控制（ABAC，Attribute-Based Access Control）：根据请求的属性（如时间、地点、设备等）来决定权限。

    5. 表单权限 实现，自己如何设计？
        根据表单字段量级进行配置：
        1. 如果较少，可以在角色与表单关联信息中增加冗余字段。
        2. 如果较多，则可以增加表单字段权限表，关联角色与表单权限及表单字段权限。

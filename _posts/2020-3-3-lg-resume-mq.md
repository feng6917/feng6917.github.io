---
layout: post
title: "面试题-MQ"
date:   2020-3-3
tags: 
  - Golang
comments: true
author: feng6917
---

`持续更新中...`

<!-- more -->

1. 消息队列的基本作用？
    <details>
    <summary>Ans</summary>
     消息队列的主要作用是：解耦、异步处理、削峰
    <ul>
        <li>解耦
        <p>A 系统通过接口调用发送数据到B、C、D 三个系统。那么如果现在 E 系统也要这个数据呢？那如果C 系统现在不需要了呢？现在A 系统又要发送第二种数据了呢？这样的话A 系统的维护成本就非常的高，而且A 系统要时时刻刻考虑B、C、D、E四个系统如果出现故障怎么办？A 系统是重发还是先把消息保存起来呢？使用消息队列就可以解决这个问题。A系统只负责生产数据，不需要考虑消息被哪个系统来消费。</p>
        </li>
        <li>异步处理
        <p>A 系统需要发送个请求给B系统处理，由于 B 系统需要查询数据库花费时间较长，以至于A 系统要等待B 系统处理完毕后再发送下个请求，造成A 系统资源浪费。使用消息队列后，A 系统生产完消息后直接丢进消息队列，不用等待B 系统的结果，直接继续去干自己的事情了。</p>
        </li>
        <li>削峰
        <p>A 系统调用B 系统处理数据，每天0点到 12点，A系统风平浪静，每秒并发请求数量就100 个。结果每次一到12点~13点，每秒并发请求数量突然会暴增到1万条。但是B系统最大的处理能力就是之恶能每秒处理1000个请求，这样系统很容易就会崩掉。这种情况引入消息队列，把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。</p>
        </li>
    </ul>
    </details>

2. 消息队列的优缺点？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>优点
        <p>解耦、异步处理、削峰</p>
        </li>
        <li>缺点
        <ul>
            <li>降低系统的可用性：系统引入的外部依赖越多，越容易挂掉。</li>
            <li>系统复杂度提高：使用MQ后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题。</li>
            <li>一致性问题：A 系统处理完了直接返回成功了，但问题是：要是B、C、D三个系统哪里，B 和 D 两个系统写库成功了，结果C 系统写库失败了，就造成数据不一致了。</li>
        </ul>
        </li>
    </ul>
    </details>

3. 如何保证消息队列的高可用？(待调整)
    <details>
    <summary>Ans</summary>
    <ul>
        <li>消息队列的常见高可用架构
        <p>1. 多主多从架构，每个主节点和从节点都保存了所有的数据，每个主节点和从节点都提供读服务，每个主节点负责提供写服务。主节点和从节点之间同步数据。</p>        <p>2. 每个主节点和从节点都保存了所有的数据，每个主节点和从节点都提供读服务，每个主节点负责提供写服务。主节点和从节点之间同步数据。</p>
        </li>
    </ul>
    </details>

4. 如何保证消息不被重复消费？或者说，如何保证消息的幂等性？
    <details>
    <summary>Ans</summary>
    要保证消息不被重复消费，其实就是要保证消息消费的幂等性。幂等性：无论你重复请求多少次，得到的结果都是一样的。例如：一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
    <ol>
        <li>写数据时，先根据主键查一下这条数据是否已经存在，如果已经存在则 update;</li>
        <li>数据库的唯一键约束也可以保证不会重复插入多条，因为重复插入多条只会报错，不会导致数据库出现脏数据。</li>
        <li>如果是写redis，就没有问题，因为set操作时天然幂等性的。</li>
    </ol>
    </details>

5. 如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>消息丢失的场景
        <p>1. 生产者发送消息时，网络故障导致发送失败。</p>
        <p>2. 消息队列宕机，导致消息丢失。</p>
        <p>3. 消费者消费消息时，网络故障导致消费失败。</p>
        </li>
        <li>消息丢失的解决方法
        <p>1. 生产者发送消息时，采用同步发送，确保消息发送成功。</p>
        <p>2. 消息队列采用持久化机制，将消息持久化到磁盘。</p>
        <p>3. 消费者消费消息时，采用手动提交offset的方式，确保消息被消费成功。</p>
        </li>
    </ul>
    </details>

6. 如何保证消息的顺序性？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>消息顺序性
        <p>消息队列中的消息，同一个队列中的消息，其顺序是一定的，但是不同队列之间的消息顺序是不一定的。</p>
        </li>
        <li>保证消息顺序性的方法
        <p>写N个内存Queue，具有相同key大的数据都到同一个内存Queue;然后N个线程，每个线程分别消费一个内存Queue 即可，这样就能保证顺序性。</p>
        </li>
    </ul>
    </details>

7. 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>消息队列的延时以及过期失效问题
        <p>消息队列中的消息，如果长时间没有被消费，就会导致消息积压，从而影响系统的正常运行。</p>
        </li>
        <li>解决方法
        <p>1. 消息积压后，优先处理积压的消息，然后再处理新的消息。</p>        <p>2. 对消息进行分类，将不同类型的消息放到不同的队列中，然后对不同的队列进行不同的处理。</p>
        <p>3. 对消息进行重试，如果消息处理失败，则将消息重新放回队列中，等待下次处理。</p>        <p>4. 对消息进行过期处理，如果消息在一段时间内没有被消费，则将消息删除。</p>
        <p>5. 对消息进行限流，对消息的消费进行限速，避免消息积压。还可以通过优化消费者的处理逻辑、增加消费者的数量、使用更高效的消息队列系统等方式来减少消息积压。</p>
        </li>
    </ul>
    </details>

8. MQ 中的消息过期失效了怎么办？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>消息过期失效
        <p>消息队列中的消息，如果在一定时间内没有被消费，就会过期失效。</p>
        </li>
        <li>解决方法
        <p>1. 消息过期后，可以通过消息重试机制，将消息重新放回队列中，等待下次处理。</p>        <p>2. 消息过期后，可以通过消息过期处理机制，将消息删除。</p>
        <p>3. 消息过期后，可以通过消息通知机制，将消息通知给相关系统，由相关系统进行处理。</p>
        </li>
        <p>大量积压-批量重导，大量积压的时候，直接丢弃数据了，然后等过了高峰期以后开始写程序，将丢失的数据一点点查出来，然后重新灌入 MQ 里面，把丢失的数据补回来。</p>
    </ul>
    </details>

9. RabbitMQ 有哪些重要的角色？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>RabbitMQ 的角色
        <p>1. 生产者：消息的创建者，负责创建和推送数据到消息服务器。</p>
        <p>2. 消费者：消费的接收方，用于处理数据和确认消息。</p>
        <p>3. 代理：就是RabbitMQ本身，用于扮演 “快递” 的角色，本身不生产消息，只是扮演 “快递” 的角色。。</p>
        <p>4. 队列：存储消息，等待消费者消费。</p>
        </li>
    </ul>
    </details>

10. RabbitMQ 有哪些重要的组件？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>RabbitMQ 的组件
        <ol>
            <li>ConnectionFactory(连接管理器)：应用程序与Rabbit之间建立的管理器，程序代码中使用。</li>
            <li>Channel(信道)：消息推送使用的信道。</li>
            <li>Exchange(交换器): 用于接收，分配消息。</li>
            <li>Queue(队列)：用于存储生产者的消息。</li>
            <li>RoutingKey(路由键)：用于把生产者的数据分配到交换器上。</li>
            <li>BindingKey(绑定键): 用于把交换器的消息绑定到队列上。</li>
        </ol>
        </li>
    </ul>
    </details>

11. RabbitMQ 有几种广播类型？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>RabbitMQ 的广播类型
        <p>1. fanout: 广播类型，将消息发送到所有绑定到交换器的队列中。</p>
        <p>2. direct: 直接类型，将消息发送到与路由键完全匹配的队列中。</p>
        <p>3. topic: 主题类型，将消息发送到与路由键匹配的队列中。</p>
        </li>
    </ul>
    </details>

12. Kafka 可以脱离 zookeeper 单独使用吗？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>Kafka 可以脱离 zookeeper 单独使用吗？
        <p></p>
        <p>Kafka 可以脱离 ZooKeeper 单独使用，但这并不是推荐的做法。ZooKeeper 在 Kafka 中扮演着非常重要的角色，它负责管理 Kafka 集群的状态，包括 broker 的注册、topic 的分区信息、消费者的消费位置等。</p>
        <p>如果脱离 ZooKeeper 使用 Kafka，那么 Kafka 将无法正常工作。例如，Kafka 集群将无法选举出 leader，无法进行分区副本的选举，也无法进行消费者的 rebalance 等。</p>
        <p>因此，推荐的做法是使用 ZooKeeper 来管理 Kafka 集群。如果确实需要脱离 ZooKeeper，那么可以考虑使用其他一些分布式协调服务，如 etcd、Consul 等。但是，这些服务可能需要额外的配置和管理工作，而且可能无法完全替代 ZooKeeper 的功能。</p>
        </li>
    </ul>
    </details>

13. Kafka 有几种数据保留的策略？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>Kafka 有几种数据保留的策略？
        <p>1. 基于时间：可以配置 Kafka 保留数据的时间长度，例如保留最近一周的数据。当数据超过这个时间长度时，Kafka 会自动删除这些数据。</p>
        <p>2. 基于大小：可以配置 Kafka 保留数据的大小，例如保留总共 1TB 的数据。当数据总量超过这个大小时，Kafka 会自动删除旧的数据。</p>
        <p>3. 基于时间和大小的混合策略：可以同时配置基于时间和大小的策略，例如保留最近一周的数据，并且总共保留 1TB 的数据。当数据超过这个时间长度或数据总量超过这个大小时，Kafka 会自动删除旧的数据。</p>
        </li>
    </ul>
    </details>

14. Kafka 的分区策略有哪些？
    <details>
    <summary>Ans</summary>
    <ul>
        <li>Kafka 的分区策略有哪些？
        <p>1. 轮询策略：按照顺序将消息发送到每个分区，确保每个分区的消息数量尽可能均匀。</p>
        <p>2. 随机策略：随机地将消息发送到每个分区，无法保证每个分区的消息数量均匀。</p>
        <p>3. 按照消息的 key 分配策略：根据消息的 key，将消息发送到对应的分区。如果 key 相同，则发送到同一个分区；如果 key 不同，则发送到不同的分区。</p>
        <p>4. 按照自定义策略：根据业务需求，自定义分区策略。</p>
        </li>
    </ul>
    </details>
